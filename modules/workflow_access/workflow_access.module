<?php

/**
 * @file
 * Provides node access permissions based on workflow states.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\workflow\Entity\Workflow;
use Drupal\workflow\Entity\WorkflowTransitionInterface;

/**
 * Implements hook_help().
 */
function workflow_access_help($route_name, RouteMatchInterface $route_match) {
  $output = '';

  switch ($route_name) {
    case 'entity.workflow_type.access_form':
      $url = \Drupal\Core\Url::fromRoute('workflow.access.settings');
      $output .= t("WARNING: Use of the 'Edit any', 'Edit own', and even 'View
        published content' permissions for the content type may override these
        access settings. You may need to <a href=':url'>alter the priority of
        the Workflow access module</a>.", array(':url' => $url->toString())
      );
      if (\Drupal::moduleHandler()->moduleExists('og')) {
        $output .= '<br>';
        $output .= t('WARNING: Organic Groups (OG) is present and may interfere
          with these settings.');
//        $output .= ' ';
//        $url = \Drupal\Core\Url::fromUri('admin/config/group/settings'); // @todo D8: FIXME when OG module is ported.
//        $output .= t("In particular, if <a href=':url'>Strict node access
//          permissions</a> is enabled, since this may override Workflow access
//          settings.", array(':url' => $url));
        $output .= t("In particular, if <i>Strict node access
          permissions</i> is enabled, since this may override Workflow access
          settings.");
      }
      break;

    default:
      break;
  }
  return $output;
}

/**
 * Implements hook_workflow_operations().
 *
 * Create action link for access form on EntityWorkflowUIController::overviewForm.
 */
function workflow_access_workflow_operations($op, EntityInterface $entity = NULL) {
  $operations = array();
  return $operations;
}

/**
 * Implements hook_node_grants().
 *
 * Supply the workflow access grants. We are simply using
 * roles as access lists, so rids translate directly to gids.
 */
function workflow_access_node_grants(AccountInterface $account, $op) {
  return array(
    'workflow_access' => array_keys($account->getRoles()),
    'workflow_access_owner' => array($account->id()),
  );
}

/**
 * Implements hook_node_access_records().
 *
 * Returns a list of grant records for the passed in node object.
 * This hook is invoked by function node_access_acquire_grants().
 */
function workflow_access_node_access_records(\Drupal\node\NodeInterface $node) {
  $grants = array();

  // Only relevant for content with Workflow.
  if (!isset($node->workflow_transitions)) {
    $node->workflow_transitions = array();
    // Sometimes, a node is saved without going through workflow_transition_form.
    // E.g.,
    // - when saving a node with workflow_node programmatically with node_save();
    // - when changing a state on a node view page/history tab;
    // - when rebuilding permissions via batch for workflow_node and workflow_field.
    // In that case, we need to create the workflow_transitions ourselves to
    // calculate the grants.
    foreach (_workflow_info_fields($node, 'node') as $field_name => $field) {
      $old_sid = FALSE;
      // Create a dummy transition, just to set $node->workflow_transitions.
      if (isset($node->workflow)) {
        $old_sid = $new_sid = $node->workflow;
      }
      elseif (isset($node->{$field_name}[\Drupal\Core\Language\Language::LANGCODE_NOT_SPECIFIED])) {
        $old_sid = $new_sid = _workflow_get_sid_by_items($node->{$field_name}[\Drupal\Core\Language\Language::LANGCODE_NOT_SPECIFIED]);
      }
      if ($old_sid) {
        /* @var $transition WorkflowTransitionInterface */
        $transition = WorkflowTransition::create([$old_sid, 'field_name' => $field_name]);
        $transition->setTargetEntity($node);
        $transition->setValues($new_sid, $node->getOwnerId(), REQUEST_TIME, '');

        // Store the transition, so it can be easily fetched later on.
        // Store in an array, to prepare for multiple workflow_fields per entity.
        // This is a.o. used in hook_entity_update to trigger 'transition post'.
        $node->workflow_transitions[$field_name] = $transition;
      }
    }
  }

  // Get 'author' of this entity.
  // - Some entities (e.g., taxonomy_term) do not have a uid.
  // But then again: node_access is only for nodes...
  $uid = !$node->getOwnerId() ? $node->getOwnerId() : 0;

  $count = 0;
  foreach ($node->workflow_transitions as $transition) {
    // @todo: add support for +1 workflows per entity.
    if ($count++ == 1 ) {
      continue;
    }

    $field_name = $transition->field_name;
    $priority = \Drupal::config('workflow_access.settings')->get('workflow_access_priority');
    // @todo: $priority = $this->config('workflow_access.settings')->get('workflow_access_priority');

    if ($current_sid = workflow_node_current_state($node, 'node', $field_name)) {
      foreach (workflow_access_get_workflow_access_by_sid($current_sid) as $rid => $grant) {
        $realm = ($uid > 0 && $rid == WORKFLOW_ROLE_AUTHOR_RID) ? 'workflow_access_owner' : 'workflow_access';
        $gid = ($uid > 0 && $rid == WORKFLOW_ROLE_AUTHOR_RID) ? $uid : $rid;

        // Anonymous ($uid == 0) author is not allowed for role 'author' (== -1).
        // Both logically (Anonymous having more rights then authenticated)
        // and technically: $gid must be a positive int.
        if ($gid < 0) { // if ($uid == 0 && $grant->rid == WORKFLOW_ROLE_AUTHOR_RID) {
          continue;
        }

        $grants[] = array(
          'realm' => $realm,
          'gid' => $gid,
          'grant_view' => $grant->grant_view,
          'grant_update' => $grant->grant_update,
          'grant_delete' => $grant->grant_delete,
          'priority' => $priority,
          'field_name' => $field_name, // Just for analysis and info.
        );
      }
    }
  }
  return $grants;
}

/**
 * Implements hook_node_access_explain().
 *
 * This is a Devel Node Access hook.
 */
function workflow_access_node_access_explain($row) {
  static $interpretations = array();
  switch ($row->realm) {
    case 'workflow_access_owner':
      $interpretations[$row->gid] = t('Workflow access: author of the content may access');
      break;

    case 'workflow_access':
      $roles = user_roles();
      $interpretations[$row->gid] = t('Workflow access: %role may access', array('%role' => $roles[$row->gid]));
      break;
  }
  return (!empty($interpretations[$row->gid]) ? $interpretations[$row->gid] : NULL);
}

/**
 * DB functions - all DB interactions are isolated here to make for easy updating should our schema change.
 */

/**
 * Given a sid, retrieve the access information and return the row(s).
 */
function workflow_access_get_workflow_access_by_sid($sid) {
  return  \Drupal::config('workflow_access.role')->get($sid);
}

/**
 * Given a sid, delete all access data for this state.
 */
function workflow_access_delete_workflow_access_by_sid($sid) {
  \Drupal::configFactory()->getEditable('workflow_access.role')
    ->clear($sid)
    ->save();
}

/**
 * Given data, insert into workflow access - we never update.
 */
function workflow_access_insert_workflow_access_by_sid($sid, &$data, \Drupal\Core\Config\Config $config = NULL) {
  $config = \Drupal::configFactory()->getEditable('workflow_access.role');
  $config
    ->set($sid, $data)
    ->save();
}
