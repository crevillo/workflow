<?php

/**
 * @file
 * Support workflows made up of arbitrary states.
 */

define('WORKFLOW_CREATION_STATE', 1);
define('WORKFLOW_CREATION_DEFAULT_WEIGHT', -50);
define('WORKFLOW_DELETION', 0);
// Couldn't find a more elegant way to preserve translation.
define('WORKFLOW_CREATION_STATE_NAME', '(' . t('creation') . ')');

// Add brackets to indicate a special role, and distinguish from frequently used 'author' role.
define('WORKFLOW_ROLE_AUTHOR_NAME', '(' . t('author') . ')');
define('WORKFLOW_ROLE_AUTHOR_RID', 'workflow_author');

// The definition of the Field_info property type. Shared between 'workflow_field' and 'workflow_rules'.
define('WORKFLOWFIELD_PROPERTY_TYPE', 'text'); // @todo: 'list', 'text' or 'workflow'?

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\workflow\Entity\Workflow;
use Drupal\workflow\Entity\WorkflowState;
use Drupal\workflow\Entity\WorkflowTransitionInterface;

module_load_include('inc', 'workflow', 'workflow.form');

/**********************************************************************
 *
 * Info hooks.
 *
 */

/**
 * Implements hook_help().
 */
function workflow_help($route_name, RouteMatchInterface $route_match) {
  $output = '';

  switch ($route_name) {
    case 'help.page.workflow':
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Workflow module adds a field to Entities to
        store field values as Workflow states. You can control "state transitions"
        and add action to specific transitions.') . '</p>';
  }
  return $output;
}

/**
 * Implements hook_admin_paths_alter().
 *
 * If entity edits are done in admin mode, then workflow history tab will be too.
 *
 * @todo: add support for every $entity_type.
 */
function workflow_admin_paths_alter(&$paths) {
  workflow_debug(__FILE__, __FUNCTION__, __LINE__);  // @todo D8-port: still test this snippet.

  if (isset($paths['node/*/edit'])) {
    $paths['node/*/workflow'] = $paths['node/*/edit'];
  }
  if (isset($paths['user/*/edit'])) {
    $paths['user/*/workflow'] = $paths['user/*/edit'];
  }
}

/**
 * Implements hook_hook_info().
 *
 * Allow adopters to place their hook implementations in either
 * their main module or in a module.workflow.inc file.
 */
function workflow_hook_info() {
//  workflow_debug(__FILE__, __FUNCTION__, __LINE__);  // @todo D8-port: still test this snippet.

  $hooks['workflow'] = array('group' => 'workflow');
  return $hooks;
}

/**
 * Implements hook_forms().
 *
 * Allows the workflow tab form to be repeated multiple times on a page.
 * @see http://drupal.org/node/1970846
 * @see https://www.drupal.org/node/2188851
 */
function workflow_forms($form_id, $args) {
  workflow_debug(__FILE__, __FUNCTION__, __LINE__);  // @todo D8-port: still test this snippet.

  $forms = array();
  if (strpos($form_id, 'workflow_transition_form_') !== FALSE) {
    $forms[$form_id] = array('callback' => 'workflow_transition_form');
  }
  // For the 'edit a comment' form.
  if (strpos($form_id, 'WorkflowTransition_edit_') !== FALSE) {
    $forms[$form_id] = array('callback' => 'workflow_transition_wrapper_form');
  }

  return $forms;
}

/**
 * Implements hook_entity_type_build().
 *
 * @see https://www.drupal.org/node/2196275 "hook_entity_info() renamed to hook_entity_type_build()"
 */
function TODOworkflow_entity_type_build(array &$entity_types) {
  workflow_debug(__FILE__, __FUNCTION__, __LINE__);  // @todo D8-port: still test this snippet.

  /* @var $entity_types \Drupal\Core\Entity\EntityTypeInterface[] */
  // Add a form controller for a custom entity form without overriding the
  // default entity form. To override the default entity form,
  // use hook_entity_type_alter().
  //$entity_types['node']->setFormClass('mymodule_foo', 'Drupal\mymodule\NodeFooFormController');
}

/**********************************************************************
 *
 * CRUD hooks.
 *
 */

/**
 * Implements hook_user_cancel().
 *
 * Update tables for deleted account, move account to user 0 (anon.)
 * ALERT: This may cause previously non-Anonymous posts to suddenly
 * be accessible to Anonymous.
 */
function workflow_user_cancel($edit, $account, $method) {
  Workflow::workflowManager()->cancelUser($edit, $account, $method);
}

/**
 * Implements hook_user_delete().
 */
function workflow_user_delete($account) {
  Workflow::workflowManager()->deleteUser($account);
}

/**
 * Implements hook_user_role_insert().
 *
 * Make sure new roles are allowed to participate in workflows by default.
 */
function workflow_user_role_insert($role) {
  Workflow::workflowManager()->insertUserRole($role);
}

/**
 * Implements hook_entity_insert().
 */
function workflow_entity_insert(EntityInterface $entity) {
  workflow_entity_update($entity);
}

/**
 * Implements hook_entity_update().
 */
function workflow_entity_update(EntityInterface $entity) {
  // Avoid this hook on workflow objects.
  if (!in_array($entity->getEntityTypeId(), [
    'workflow_workflow',
    'workflow_state',
    'workflow_config_transition',
    'workflow_transition',
    'workflow_scheduled_transition',
  ])) {
    // Execute/save the transitions fom the widgets in the entity form.
    Workflow::workflowManager()->executeTransitionsOfEntity($entity);
  }
}

/**
 * Implements hook_cron().
 *
 * Given a timeframe, execute all scheduled transitions.
 */
function workflow_cron() {
  Workflow::workflowManager()->executeScheduledTransitionsBetween(0, REQUEST_TIME);
}

/**
 * Business related functions, the API.
 */

/**
 * Executes a transition (change state of an entity), from OUTSIDE the entity,
 *
 * Use workflow_execute_transition($transition) to start a State Change from
 * outside an entity, e.g., workflow_cron().
 * Use $transition->execute() to start a State Change from within an entity.
 *
 * N.B. This function updates Entity, but not workflow_transition_* tables.
 *
 * @param WorkflowTransitionInterface $transition
 *   A WorkflowTransition or WorkflowScheduledTransition.
 * @param bool $force
 *   If set to TRUE, workflow permissions will be ignored.
 *
 * @return string
 *   The new WorkflowState ID.
 */
function workflow_execute_transition(WorkflowTransitionInterface $transition, $force = FALSE) {
  $to_sid = '';

  /*
   * Input
   */
  $field_name = $transition->getFieldName();
  $entity = $transition->getEntity();

  /*
   * Step 1: Update the Transition in the History/Schedule tables.
   */
  if ($force) {
    $transition->force($force);
  }
  // The transition has been executed.
  $transition->schedule(FALSE);
  // Validate transition, save in history table and delete from schedule table.
  $to_sid = $transition->execute(TRUE);

  /*
   * Step 2: Update entity to update the field.
   */
  if (!$transition->isScheduled()) {
    $result = $transition->updateEntity();
  }

  return $to_sid;
}

/**
 * Functions to get an options list (to show in a Widget).
 * To be used in non-OO modules, like workflow_rules, workflow_views.
 *
 * The naming convention is workflow_get_<entity_type>_names.
 * (A bit different from 'user_role_names'.)
 * Can be used for hook_allowed_values from list.module.
 * Todo: move to \Drupal::entityManager::getEntityTypeLabels($group = FALSE).
 * - user_role
 * - workflow
 * - workflow_state
 * - sid
 */

/**
 * Get a list of roles.
 *
 * deprecated D8: workflow_get_roles --> workflow_get_user_role_names
 *
 * @param $permission
 *   The permission to filter with.
 *
 * @return array $options
 *   Array of role names keyed by role ID, including the 'author' role.
 */
function workflow_get_user_role_names($permission = 'participate in workflow') {
  static $roles = NULL;

  if (!$roles[$permission]) {
    $roles[$permission] =
      array(WORKFLOW_ROLE_AUTHOR_RID => WORKFLOW_ROLE_AUTHOR_NAME) +
      // Copied from AccountForm::form().
      array_map(array('\Drupal\Component\Utility\SafeMarkup', 'checkPlain'), user_role_names(TRUE));
  }

  return $roles[$permission];
}

/**
 * Get an options list for workflow states.
 *
 * @param mixed $wid
 *   The Workflow ID.
 * @param bool $grouped
 *   Indicates if the value must be grouped per workflow.
 *   This influence the rendering of the select_list options.
 * @param bool $all
 *   Indicates to return all (TRUE) or active (FALSE) states of a workflow.
 *
 * @return array $options
 *   An array of $sid => state->label(), grouped per Workflow.
 */
function workflow_get_workflow_state_names($wid = '', $grouped = FALSE, $all = FALSE) {
  $options = array();

  // Get the (user-dependent) options.
  // Since this function is only used in UI, it is save to use the global $user.
  $user = workflow_current_user();

  foreach ($workflows = Workflow::loadMultiple($wid ? array($wid) : NULL) as $workflow) {
    $workflow_options = array();

    $state = WorkflowState::create(array('wid' => $workflow->id()));
    $workflow_options = $state->getOptions(NULL, '', $user, FALSE);
    if (!$grouped) {
      $options += $workflow_options;
    }
    else {
      // Make a group for each Workflow.
      $options[$workflow->label()] = $workflow_options;
    }
  }

  return $options;
}

/**
 * Get an options list for workflows.
 *
 * @return array $options
 *   An array of $wid => workflow->label().
 */
function workflow_get_workflow_names() {
  $options = array();

  foreach (Workflow::LoadMultiple() as $wid => $workflow) {
    $options[$wid] = $workflow->label();
  }

  return $options;
}

/**
 * Helper function, to get the label of a given State Id.
 *
 * @param $sid
 *
 * @return string
 *
 * deprecated: workflow_get_sid_label() --> workflow_get_sid_name()
 */
function workflow_get_sid_name($sid) {

  if (empty($sid)) {
    $label = 'No state';
  }
  elseif ($state = WorkflowState::load($sid)) {
    $label = $state->label();
  }
  else {
    $label = 'Unknown state';
  }
  return t($label);
}

/**
 * Determines the Workflow field_name of an entity.
 * If an entity has more workflows, only rturns the first one.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity at hand.
 * @param string $field_name
 *   The field name. If given, will be passed as return value.
 *
 * @return string
 */
function workflow_get_field_name(EntityInterface $entity, $field_name = '') {
  if (!$entity) {
    // $entity may be empty on Entity Add page.
    $field_name = '';
  }
  elseif (!$field_name ) {
    $entity_type = $entity->getEntityTypeId();
    $fields = _workflow_info_fields($entity, $entity_type);
    $field_names = array_keys($fields);
    $field_name = reset($field_names);
  }

  return $field_name;
}

/**
 * Helper function to get the entity from a route.
 *
 * This is a hack. It should be solved by using $routematch.
 *
 * @param \Drupal\Core\Entity\EntityInterface|NULL $entity
 *
 * @return \Drupal\Core\Entity\EntityInterface
 */
function workflow_url_get_entity(EntityInterface $entity = NULL) {
  if (!$entity) {
    $route_match = \Drupal::routeMatch();
    // On node pages, we'd get an object.
    $entity = $route_match->getParameter('node');
    if(!$entity) {
      // On term pages, we get objects, or id's.
      $entity = $route_match->getParameter('taxonomy_term');
      if (!$entity) {
        // We may be on a entity add page/
        // Or we may be on a page of some unknown entity.
      }
      elseif (!is_object($entity)) {
        $entity = \Drupal\taxonomy\Entity\Term::load($entity);
      }
    }
  }

  return $entity;
}

/**
 * Helper function to get the entity from a route.
 *
 */
function workflow_url_get_operation(EntityInterface $entity = NULL) {
  $url = \Drupal\Core\Url::fromRoute('<current>');
  // The last part of the path is the operation: edit, workflow, devel.
  $url_parts = explode('/', $url->toString());
  $operation = array_pop($url_parts);
  // Except for view pages.
  if (is_numeric($operation) || $operation == 'view') {
    $operation = '';
  }
  return $operation;
}

/**
 * Functions to get the state of an entity.
 */

/**
 * Wrapper function
 *
 * @return \Drupal\Core\Session\AccountProxyInterface
 */
function workflow_current_user() {
  return \Drupal::currentUser();
}

/**
 * Gets the current state ID of a given entity.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 * @param string $field_name
 *
 * @return string $current_sid
 *
 * @deprecated : use Workflow::workflowManager()->getCurrentStateID()
 */
function workflow_node_current_state(EntityInterface $entity, $field_name = '') {
  return Workflow::workflowManager()->getCurrentStateID($entity, $field_name);
}

/**
 * Gets the previous state ID of a given entity.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 * @param string $field_name
 *
 * @return string $previous_sid
 *
 * @deprecated : use Workflow::workflowManager()->getPreviousStateID()
 */
function workflow_node_previous_state($entity, $field_name = '') {
  return Workflow::workflowManager()->getPreviousStateId($entity, $field_name);
}

/**
 * Get a specific workflow, given an entity type. Only one workflow is possible per node type.
 *
 * @param string $entity_bundle
 *   An entity bundle.
 * @param string $entity_type
 *   An entity type. This is passed when also the Field API must be checked.
 *
 * @return Workflow
 *   A Workflow object, or FALSE if no workflow is retrieved.
 *
 * Caveat: gives undefined results with multiple workflows per entity.
 *
 * @todo: support multiple workflows per entity.
 */
function workflow_get_workflows_by_type($entity_bundle, $entity_type) {

  static $map = array();

  if (!isset($map[$entity_type][$entity_bundle])) {
    $wid = FALSE;
    $map[$entity_type][$entity_bundle] = FALSE;
    if (!$wid && isset($entity_type)) {
      foreach (_workflow_info_fields(NULL, $entity_type, $entity_bundle) as $field_name => $field_info) {
        $wid = $field_info->getSetting('workflow_type');
      }
    }

    // Set the cache with a workflow object.
    if ($wid) {
      // $wid can be numeric or named.
      $workflow = Workflow::load($wid);
      $map[$entity_type][$entity_bundle] = $workflow;
    }
  }
  return $map[$entity_type][$entity_bundle];
}

/**
 * Get a single value from an Field API $items array.
 *
 * @param array $items
 *   Array with values, as passed in the hook_field_<op> functions.
 *   Although we are parsing an array,
 *   the Workflow Field settings ensure that the cardinality is set to 1.
 *
 * @return int $sid
 *   A State ID.
 */
function _workflow_get_sid_by_items(array $items) {
  workflow_debug(__FILE__, __FUNCTION__, __LINE__);  // @todo D8-port: still test this snippet.
  // On a normal widget:
  $sid = isset($items[0]['value']) ? $items[0]['value'] : 0;
  // On a workflow form widget:
  $sid = isset($items[0]['workflow']['workflow_sid']) ? $items[0]['workflow']['workflow_sid'] : $sid;
  return $sid;
}

/**
 * Gets the workflow field names, if not known already.
 *
 * For workflow_field, multiple workflows per bundle are supported.
 * For workflow_node, only one 'field' structure is returned.
 *
 * @param EntityInterface $entity
 *   Object to work with. May be empty, e.g., on menu build.
 * @param string $entity_type
 *   Entity type of object. Optional, but required if $entity provided.
 * @param string $entity_bundle
 *   Bundle of entity. Optional.
 * @param string $field_name
 *   Field name. Optional.
 *
 * @return Drupal\field\Entity\FieldStorageConfig[] $field_info
 *   An array of FieldStorageConfig objects.
 */
function _workflow_info_fields($entity = NULL, $entity_type = '', $entity_bundle = '', $field_name = '') {
  $field_info = array();

  // Figure out the $entity's bundle and id.
  if ($entity) {
    $entity_type = $entity->getEntityTypeId();
    $entity_bundle = $entity->bundle();
  }
  else {
    // Entity type and bundle should be specified.
  }

  $field_list = Drupal::entityManager()->getFieldMapByFieldType('workflow');
  foreach ($field_list as $e_type => $data) {
    if (!$entity_type || ($entity_type == $e_type)) {
      foreach($data as $f_name => $data) {
        if (!$entity_bundle || isset($data['bundles'][$entity_bundle])) {
          if (!$field_name || ($field_name == $f_name)) {
            $field_info[$f_name] = \Drupal\field\Entity\FieldStorageConfig::loadByName($e_type, $f_name);
          }
        }
      }
    }
  }
  return $field_info;
}

/**
 * Helper function for D8-port> Get some info on screen
 *
 * Usage:
 *   workflow_debug( __FILE__ , __FUNCTION__, __LINE__);  // @todo D8-port: still test this snippet.
 *
 * @param string $class_name
 * @param string $function_name
 * @param string $line
 * @param string $value1
 * @param string $value2
 *
 */
function workflow_debug($class_name, $function_name, $line = '', $value1 = '', $value2 = '') {
  $debug_switch = FALSE;
//  $debug_switch = TRUE;

  if (!$debug_switch || !function_exists('dpm')) {
    return;
  }

  $class_name_elements = explode( "\\" , $class_name);
  $output = 'TODO D8-port: test function ' . end($class_name_elements) . '::' . $function_name . '/' . $line;
  if ($value1) {
    $output .= ' = ' . $value1;
  }
  if ($value2) {
    $output .= ' > ' . $value2;
  }
  if (function_exists('dpm')) { dpm($output); }
}

//module_load_include('inc', 'workflow', 'workflow.api.php');
