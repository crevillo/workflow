<?php

/**
 * @file
 * Support workflows made up of arbitrary states.
 */

define('WORKFLOW_CREATION_STATE', 1);
define('WORKFLOW_CREATION_DEFAULT_WEIGHT', -50);
define('WORKFLOW_DELETION', 0);
// Couldn't find a more elegant way to preserve translation.
define('WORKFLOW_CREATION_STATE_NAME', '(' . t('creation') . ')');

// Add brackets to indicate a special role, and distinguish from frequently used 'author' role.
define('WORKFLOW_ROLE_AUTHOR_NAME', '(' . t('author') . ')');
define('WORKFLOW_ROLE_AUTHOR_RID', 'workflow_author');

// The definition of the Field_info property type. Shared between 'workflow_field' and 'workflow_rules'.
define('WORKFLOWFIELD_PROPERTY_TYPE', 'text'); // @todo: 'list', 'text' or 'workflow'?

use Drupal\Core\Cache\Cache;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Language\Language;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\workflow\Entity\Workflow;
use Drupal\workflow\Entity\WorkflowState;
use Drupal\workflow\Entity\WorkflowScheduledTransition;
use Drupal\workflow\Entity\WorkflowTransition;
use Drupal\workflow\Entity\WorkflowTransitionInterface;

module_load_include('inc', 'workflow', 'workflow.form');

/**
 * Implements hook_help().
 */
function workflow_help($route_name, RouteMatchInterface $route_match) {
  $output = '';

  switch ($route_name) {
    case 'help.page.workflow':
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Workflow module adds a field to Entities to
        store field values as Workflow states. You can control "state transitions"
        and add action to specific transitions.') . '</p>';
  }
  return $output;
}

/**
 * Implements hook_menu_alter().
 */
function workflow_menu_alter(&$items) {
//  dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ );

  return; // TODO D8-port: test this function.

  $items['workflow_transition/%workflow_transition/edit'] = array(
    // %workflow_transition maps to function workflow_transition_load()
    'title' => 'Edit workflow log comment',
    'description' => 'Edit workflow transition comment.',
//    'page callback' => 'drupal_get_form',
//    'page arguments' => array('workflow_transition_form_wrapper', 1),
    'page callback'        => 'entity_ui_get_form',
    // @todo: below parameter should be the machine_name of the entity type.
    'page arguments'    => array('WorkflowTransition', 1),
    'access arguments' => array('edit workflow comment'),
//    'file' => 'workflow.transition.page.inc',
    'menu wildcard' => '%workflow_transition',
  );

  $menu_item = array(
    'title' => 'Workflow',
    'page callback' => 'workflow_tab_page',
    'access callback' => 'workflow_tab_access',
    'file' => 'workflow.pages.inc',
    'file path' => drupal_get_path('module', 'workflow'),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK,
    'module' => 'workflow',
  );

  // Get a cross-bundle map of all workflow fields so we can add the workflow
  // tab to all entities with a workflow field.
  foreach (_workflow_info_fields() as $field_info) {
    if (TRUE) {
      // Loop over the entity types that have this field.
      foreach ($field_info['bundles'] as $type => $bundles) {
        // D7: $entity_info = entity_get_info($type);
        $entity_info = \Drupal::entityManager()->getDefinition($type);

        // Add the workflow tab in the Entity Admin UI.
        if (!empty($entity_info['admin ui']['path'])) {
          $entity_position = substr_count($entity_info['admin ui']['path'], '/') + 2;
          $wildcard = (isset($entity_info['admin ui']['menu wildcard']) ? $entity_info['admin ui']['menu wildcard'] : '%entity_object');
          $items[$entity_info['admin ui']['path'] . '/manage/' . $wildcard . '/workflow'] = $menu_item + array(
              'page arguments' => array($type, $entity_position),
              'access arguments' => array($type, $entity_position),
              'load arguments' => array($type),
            );
        }

        // We can only continue if the entity relies on a ENTITY_TYPE_load() load hook.
        if ($entity_info['load hook'] == $type . '_load') {
          try {
            foreach ($bundles as $bundle) {
              // Get the default entity values.
              $values = array($entity_info['entity keys']['id'] => '%' . $type);
              if ($entity_info['entity keys']['bundle']) {
                $values[$entity_info['entity keys']['bundle']] = $bundle;
              }

              // Create a dummy entity and get the URI.
              // D7: $entity = @entity_create($type, $values);
              $entity = @\Drupal::entityManager()->getStorage($type)->create($values);
              $uri = entity_uri($type, $entity);
              if (isset($uri['path'])) {
                $uri = $uri['path'];

                // Add the workflow tab if possible.
                if (isset($items[$uri]) && !isset($items[$uri . '/workflow'])) {
                  $entity_position = array_search('%' . $type, explode('/', $uri));

                  if ($entity_position) {
                    $items[$uri . '/workflow'] = $menu_item + array(
                        'page arguments' => array($type, $entity_position),
                        'access arguments' => array($type, $entity_position),
                      );
                  }
                }
              }
            }
          }
          catch (Exception $ex) {
            // The $type entity could not be created or the URI building failed.
          }
        }
      }
    }
  }
}

/**
 * Implements hook_admin_paths_alter().
 *
 * If entity edits are done in admin mode, then workflow history tab will be too.
 *
 * @todo: add support for every $entity_type.
 */
function workflow_admin_paths_alter(&$paths) {
//  dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ );

  if (isset($paths['node/*/edit'])) {
    $paths['node/*/workflow'] = $paths['node/*/edit'];
  }
  if (isset($paths['user/*/edit'])) {
    $paths['user/*/workflow'] = $paths['user/*/edit'];
  }
}

/**
 * Menu access control callback. Determine access to Workflow tab.
 *
 * The History tab should not be used with multiple workflows per entity.
 * Use the dedicated view for this use case.
 *
 * @param string $entity_type
 *   The entity type of the attached $entity.
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity type of this Entity subclass.
 *
 * @todo D8: remove this in favour of View 'Workflow history per entity'.
 */
function workflow_tab_access($entity_type, $entity) {
  dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ );

  $user = \Drupal::currentUser();
  $uid = $user->id();
  static $access = array();

  // Figure out the $entity's bundle and id.
  $entity_bundle = $entity->bundle();
  $entity_id = $entity->id();

  if (isset($access[$uid][$entity_type][$entity_id])) {
    return $access[$uid][$entity_type][$entity_id];
  }

  // When having multiple workflows per bundle, use Views display
  // 'Workflow history per entity' instead!
  if (workflow_get_workflows_by_type($entity_bundle, $entity_type)) {
    // Get the role IDs of the user. Workflow only stores Ids, not role names.
    // TODO D8: add usage of api user_has_role().
    $roles = array_keys($user->roles);

    // Some entities (e.g., taxonomy_term) do not have a uid.
    $entity_uid = isset($entity->uid) ? $entity->uid : 0;

    // If this is a new page, give the authorship role.
    if (!$entity_id) {
      $roles = array_merge(array(WORKFLOW_ROLE_AUTHOR_RID), $roles);
    }
    // Add 'author' role to user if user is author of this entity.
    // N.B.1: Some entities (e.g, taxonomy_term) do not have a uid.
    // N.B.2: If 'anonymous' is the author, don't allow access to History Tab,
    // since anyone can access it, and it will be published in Search engines.
    elseif (($entity_uid > 0) && ($uid > 0) && ($entity_uid == $uid)) {
      $roles = array_merge(array(WORKFLOW_ROLE_AUTHOR_RID), $roles);
    }

    // Get the permissions from the workflow settings.
    // @todo: workflow_tab_access(): what to do with multiple workflow_fields per bundle? Use Views instead!
    $tab_roles = array();
    $history_tab_show = FALSE;
    $fields = _workflow_info_fields($entity, $entity_type, $entity_bundle);
    foreach ($fields as $field) {
      $tab_roles += $field['settings']['history']['roles'];
      $history_tab_show |= $field['settings']['history']['history_tab_show'];
    }

    if ($history_tab_show == FALSE) {
      $access[$uid][$entity_type][$entity_id] = FALSE;
    }
    elseif ($user->hasPermission('administer nodes') || array_intersect($roles, $tab_roles)) {
      $access[$uid][$entity_type][$entity_id] = TRUE;
    }
    else {
      $access[$uid][$entity_type][$entity_id] = FALSE;
    }
    return $access[$uid][$entity_type][$entity_id];
  }
  return FALSE;
}

/**
 * Implements hook_hook_info().
 *
 * Allow adopters to place their hook implementations in either
 * their main module or in a module.workflow.inc file.
 */
function workflow_hook_info() {
//  dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ );

  $hooks['workflow'] = array('group' => 'workflow');
  return $hooks;
}

/**
 * Implements hook_entity_type_build().
 *
 * @see https://www.drupal.org/node/2196275 "hook_entity_info() renamed to hook_entity_type_build()"
 */
function TODOworkflow_entity_type_build(array &$entity_types) {
  dpm('TODO D8-port: test (port hook-entity_info) function workflow.module::' . __FUNCTION__ );

  /* @var $entity_types \Drupal\Core\Entity\EntityTypeInterface[] */
  // Add a form controller for a custom entity form without overriding the
  // default entity form. To override the default entity form,
  // use hook_entity_type_alter().
  //$entity_types['node']->setFormClass('mymodule_foo', 'Drupal\mymodule\NodeFooFormController');
}

/**
 * Implements hook_features_api().
 */
function workflow_features_api() {
//  dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ );

  return array();

  return array(
    'workflow' => array(
      'name' => t('Workflow'),
      'file' => drupal_get_path('module', 'workflow') . '/workflow.features.inc',
      'default_hook' => 'workflow_default_workflows',
      'feature_source' => TRUE,
    ),
  );
}

/**
 * Implements hook_theme().
 */
function workflow_theme() {
//  dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ );

  return array(
    'workflow_history_table_row' => array(
      'variables' => array(
        'history' => NULL,
        'old_state_name' => NULL,
        'state_name' => NULL,
      ),
    ),
    'workflow_history_table' => array(
      'variables' => array(
        'header' => array(),
        'rows' => array(),
        'footer' => NULL,
      ),
    ),
    'workflow_history_current_state' => array(
      'variables' => array(
        'state_name' => NULL,
        'state_system_name' => NULL,
        'sid' => NULL,
      ),
    ),
    'workflow_current_state' => array(
      'variables' => array(
        'state' => NULL,
        'state_system_name' => NULL,
        'sid' => NULL,
      ),
    ),
    'workflow_deleted_state' => array(
      'variables' => array(
        'state_name' => NULL,
        'state_system_name' => NULL,
        'sid' => NULL,
      ),
    ),
  );
}

/**
 * Implements hook_cron().
 *
 * Given a timeframe, execute all scheduled transitions.
 */
function workflow_cron() {
  Workflow::workflowManager()->executeScheduledTransitionsBetween(0, REQUEST_TIME);
}

/**
 * Implements hook_user_cancel().
 *
 * Update tables for deleted account, move account to user 0 (anon.)
 * ALERT: This may cause previously non-Anonymous posts to suddenly
 * be accessible to Anonymous.
 */
function workflow_user_cancel($edit, $account, $method) {
  Workflow::workflowManager()->cancelUser($edit, $account, $method);
}

/**
 * Implements hook_user_delete().
 */
function workflow_user_delete($account) {
  Workflow::workflowManager()->deleteUser($account);
}

/**
 * Implements hook_user_role_insert().
 *
 * Make sure new roles are allowed to participate in workflows by default.
 */
function workflow_user_role_insert($role) {
  Workflow::workflowManager()->insertUserRole($role);
}

/**
 * Business related functions, the API.
 */

/**
 * Implements hook_forms().
 *
 * Allows the workflow tab form to be repeated multiple times on a page.
 * @see http://drupal.org/node/1970846
 * @see https://www.drupal.org/node/2188851
 */
function workflow_forms($form_id, $args) {
//  dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ );

  $forms = array();
  if (strpos($form_id, 'workflow_transition_form_') !== FALSE) {
    $forms[$form_id] = array('callback' => 'workflow_transition_form');
  }
  // For the 'edit a comment' form.
  if (strpos($form_id, 'WorkflowTransition_edit_') !== FALSE) {
    $forms[$form_id] = array('callback' => 'workflow_transition_wrapper_form');
  }

  return $forms;
}

/**
 * Executes a transition (change state of an entity), from OUTSIDE the entity,
 *
 * Use workflow_execute_transition($transition) to start a State Change from
 * outside an entity, e.g., workflow_cron().
 * Use $transition->execute() to start a State Change from within an enetity.
 *
 * N.B. This function updates Entity, but not workflow_transition_* tables.
 *
 * @param WorkflowTransitionInterface $transition
 *   A WorkflowTransition or WorkflowScheduledTransition.
 * @param bool $force
 *   If set to TRUE, workflow permissions will be ignored.
 *
 * @return string
 *   The new WorkflowState ID.
 */
function workflow_execute_transition(WorkflowTransitionInterface $transition, $force = FALSE) {

  $field_name = $transition->getFieldName();
  $entity = $transition->getEntity();
  // @todo: use $new_sid = $transition->execute() without generating infinite loops.

  // Step 1: Update entity to update the field.
  // D7: This will call hook_field_update() and WorkflowFieldDefaultWidget::submit().
  $entity->{$field_name}->setValue($transition->getToSid());
  // @todo D7: perhaps use field_attach_update, for better performance, and not change entity properties.
  // @todo D7: if transition is scheduled or new_sid == old_sid and no comment, proceed as if no $field_name.
  $entity->save();
  // field_attach_update($entity_type, $entity);
  $new_sid = workflow_node_current_state($entity, $field_name);

  // Step 2: Update the Transition in the History/Schedule tables.
  if ($force) {
    $transition->force($force);
  }
  // The transition has been executed.
  $transition->schedule(FALSE);
  $transition->execute(TRUE);
  // Save in history table and delete from schedule table.
  $transition->save();

  return $new_sid;
}

/**
 * Functions to get an options list (to show in a Widget).
 * To be used in non-OO modules, like workflow_rules, workflow_views.
 *
 * The naming convention is workflow_get_<entity_type>_names.
 * (A bit different from 'user_role_names'.)
 * Can be used for hook_allowed_values from list.module.
 * Todo: move to \Drupal::entityManager::getEntityTypeLabels($group = FALSE).
 * - user_role
 * - workflow
 * - workflow_state
 * - sid
 */

/**
 * Get a list of roles.
 *
 * deprecated D8: workflow_get_roles --> workflow_get_user_role_names
 *
 * @param $permission
 *   The permission to filter with.
 *
 * @return array $options
 *   Array of role names keyed by role ID, including the 'author' role.
 */
function workflow_get_user_role_names($permission = 'participate in workflow') {
  static $roles = NULL;

  if (!$roles[$permission]) {
    $roles[$permission] =
      array(WORKFLOW_ROLE_AUTHOR_RID => WORKFLOW_ROLE_AUTHOR_NAME) +
      // Copied from AccountForm::form().
      array_map(array('\Drupal\Component\Utility\SafeMarkup', 'checkPlain'), user_role_names(TRUE));
  }

  return $roles[$permission];
}

/**
 * Get an options list for workflow states.
 *
 * @param mixed $wid
 *   The Workflow ID.
 * @param bool $grouped
 *   Indicates if the value must be grouped per workflow.
 *   This influence the rendering of the select_list options.
 * @param bool $all
 *   Indicates to return all (TRUE) or active (FALSE) states of a workflow.
 *
 * @return array $options
 *   An array of $sid => state->label(), grouped per Workflow.
 */
function workflow_get_workflow_state_names($wid = '', $grouped = FALSE, $all = FALSE) {
  $options = array();

  // Get the (user-dependent) options.
  // Since this function is only used in UI, it is save to use the global $user.
  $user = \Drupal::currentUser();

  foreach ($workflows = Workflow::loadMultiple($wid ? array($wid) : NULL) as $workflow) {
    $workflow_options = array();

    $state = WorkflowState::create(array('wid' => $workflow->id()));
    $workflow_options = $state->getOptions(NULL, '', $user, FALSE);
    if (!$grouped) {
      $options += $workflow_options;
    }
    else {
      // Make a group for each Workflow.
      $options[$workflow->label()] = $workflow_options;
    }
  }

  return $options;
}

/**
 * Get an options list for workflows.
 *
 * @return array $options
 *   An array of $wid => workflow->label().
 */
function workflow_get_workflow_names() {
  $options = array();

  foreach (Workflow::LoadMultiple() as $wid => $workflow) {
    $options[$wid] = $workflow->label();
  }

  return $options;
}

/**
 * Helper function, to get the label of a given State Id.
 *
 * deprecated: workflow_get_sid_label() --> workflow_get_sid_name()
 */
function workflow_get_sid_name($sid) {

  if (empty($sid)) {
    $label = 'No state';
  }
  elseif ($state = WorkflowState::load($sid)) {
    $label = $state->label();
  }
  else {
    $label = 'Unknown state';
  }
  return t($label);
}

/**
 * Functions to get the state of an entity.
 */

/**
 * Gets the current state ID of a given entity.
 *
 * There is no need to use a page cache.
 * The performance is OK, and the cache gives problems when using Rules.
 *
 * @param EntityInterface $entity
 *   The entity to check. May be an EntityDrupalWrapper.
 * @param string $entity_type
 *   The entity_type of the entity to check.
 *   May be empty in case of an EntityDrupalWrapper.
 * @param string $field_name
 *   The name of the field of the entity to check.
 *   If NULL, the field_name is determined on the spot. This must be avoided,
 *     making multiple workflow per entity unpredictable.
 *     The found field_name will be returned in the param.
 *   If '', we have a workflow_node mode.
 *
 * @return mixed $sid
 *   The ID of the current state.
 */
function workflow_node_current_state($entity, &$field_name = NULL) {
  // @TODO D8: return State object, not $sid integer.
  $sid = FALSE;
  $langcode = Language::LANGCODE_NOT_SPECIFIED;

  if (!$entity) {
    return $sid;
  }

  // If $field_name is not known, yet, determine it.
  if ($field_name === NULL) {
    dpm('TODO D8-port: test part of function workflow.module::' . __FUNCTION__.'/'.__LINE__);

    $entity_type = $entity->getEntityTypeId();
    $fields = _workflow_info_fields($entity, $entity_type);
    if (count($fields)) {
      // Workflow Field API: if $field_name is not known, yet, determine it.
      $field = reset($fields);
      $field_name = $field['field_name'];
    }
    else {
      // Workflow Node API.
      $field_name = '';
    }
  }

  // At this point, we may have redetermined and altered the field_name.
  if (!$sid) {
    $sid = $entity->$field_name->value;
  }

  // No current state. Use creation state.
  if (!$sid) {
    $sid = _workflow_get_workflow_creation_sid($entity, $field_name);
  }

  return $sid;
}

/**
 * Gets the previous state ID of a given entity.
 *
 * @param EntityInterface $entity
 * @param string $field_name
 *
 * @return string $previous_sid
 */
function workflow_node_previous_state($entity, $field_name) {
  // @todo D8: return State object, not $sid integer.
  $previous_sid = FALSE;
  $langcode = Language::LANGCODE_NOT_SPECIFIED;

  if (!$entity) {
    return $previous_sid;
  }

  $entity_type = $entity->getEntityTypeId();

  // Determine the $field_name if unknown. Just get the 1st one.)
  if ($field_name === NULL) {
    dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ . '/' . __LINE__ . ' ' . $field_name);
    $fields = _workflow_info_fields($entity, $entity_type);
    if (count($fields)) {
      $field = reset($fields);
      $field_name = $field['field_name'];
    }
  }

  // At this point, we may have redetermined and altered the field_name.
  if ($field_name !== NULL && isset($entity->original)) {
    dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ . '/' . __LINE__ . ' ' . $field_name);
    // A changed node.

    $wrapper = entity_metadata_wrapper($entity_type, $entity->original);
    $previous_sid = $wrapper->{$field_name}->value();

    // Get language. Multi-language is not supported for Workflow Node.
    $langcode = _workflow_metadata_workflow_get_properties($entity->original, array(), 'langcode', $entity_type, $field_name);
  }

  // A node may not have a Workflow attached.
  if (!$previous_sid && $field_name) {
    // Get Id. Is empty when creating a node.
    $entity_id = $entity->id();
    if (!$entity_id && $entity->isNew()) {
      // Test this situation.
      dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ . '/' . __LINE__ . ' ' . $field_name);
    }

    if ($entity->isNew()) {
      dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ . '/' . __LINE__ . ' ' . $field_name);
      // A new Node. $is_new is not set when saving terms, etc.
      $previous_sid = _workflow_get_workflow_creation_sid($entity, $field_name);
    }
    elseif (!$previous_sid && $entity_id) {
      dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ . '/' . __LINE__ . ' ' . $field_name);
      // D8: This should be done via ->original.
      //
      // Read the history with an explicit langcode.
//      if ($last_transition = workflow_transition_load_single($entity_type, $entity_id, $field_name, $langcode)) {
      if ($last_transition = WorkflowTransition::loadByProperties($entity_type, $entity_id, $field_name, $langcode)) {
        dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ . '/' . __LINE__ . ' ' . $field_name);
        $previous_sid = $last_transition->new_sid;
      }
    }
  }

  if (!$previous_sid && $field_name !== NULL) {
    // No history found on an existing entity.
    $previous_sid = _workflow_get_workflow_creation_sid($entity, $field_name);
  }

  dpm('TODO D8-port: result of function workflow.module::' . __FUNCTION__.'/'.__LINE__.' = '.$previous_sid);

  return $previous_sid;
}

/**
 * Gets the creation sid for a given $entity and $field_name.
 *
 * Is a helper function for:
 * - workflow_node_current_state()
 * - workflow_node_previous_state()
 *
 */
function _workflow_get_workflow_creation_sid($entity, $field_name) {
  $sid = '';

  $field_config = $entity->get($field_name)->getFieldDefinition();
  $field_storage = $field_config->getFieldStorageDefinition();
  $wid = $field_storage->getSetting('workflow_type');
  $workflow = Workflow::load($wid);

  if ($workflow) {
    $sid = $workflow->getCreationSid();
  }
  else {
    drupal_set_message(t('Workflow !wid cannot be loaded. Contact your system administrator.', array('!wid' => $wid)), 'error');
  }
  return $sid;
}


/**
 * Get a specific workflow, given an entity type. Only one workflow is possible per node type.
 *
 * @param string $entity_bundle
 *   An entity bundle.
 * @param string $entity_type
 *   An entity type. This is passed when also the Field API must be checked.
 *
 * @return
 *   A Workflow object, or FALSE if no workflow is retrieved.
 *
 * Caveat: gives undefined results with multiple workflows per entity.
 *
 * @todo: support multiple workflows per entity.
 */
function workflow_get_workflows_by_type($entity_bundle, $entity_type) {
//  dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ );

  static $map = array();

  if (!isset($map[$entity_type][$entity_bundle])) {
    $wid = FALSE;
    $map[$entity_type][$entity_bundle] = FALSE;

    if (!$wid && isset($entity_type)) {
      dpm('TODO D8-port: test part of function workflow.module::' . __FUNCTION__.'/'.__LINE__);
      foreach (_workflow_info_fields(NULL, $entity_type, $entity_bundle) as $field_name => $field_info) {
        $wid = $field_info['settings']['wid'];
      }
    }

    // Set the cache with a workflow object.
    if ($wid) {
      // $wid can be numeric or named.
      $workflow = Workflow::load($wid);
      $map[$entity_type][$entity_bundle] = $workflow;
    }
  }

  return $map[$entity_type][$entity_bundle];
}

/**
 * Get a single value from an Field API $items array.
 *
 * @param array $items
 *   Array with values, as passed in the hook_field_<op> functions.
 *   Although we are parsing an array,
 *   the Workflow Field settings ensure that the cardinality is set to 1.
 *
 * @return int $sid
 *   A State ID.
 */
function _workflow_get_sid_by_items(array $items) {
//  dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ );
  // On a normal widget:
  $sid = isset($items[0]['value']) ? $items[0]['value'] : 0;
  // On a workflow form widget:
  $sid = isset($items[0]['workflow']['workflow_sid']) ? $items[0]['workflow']['workflow_sid'] : $sid;
  return $sid;
}


/**
 * Determine the fields for an entity.
 * If $field_name is not known, yet, determine it.
 *
 * @return array $field_names
 *   An array of field_names.
 */
function workflow_entity_fields($entity, $field_name = '') {
  $fields = _workflow_info_fields($entity);
  dpm('TODO D8-port: test part of function workflow.module::' . __FUNCTION__.'/'.__LINE__);
  dpm($fields, __FUNCTION__);
  dpm(array_keys($fields));
  if ($field_name) {
    dpm('TODO D8-port: test part of function workflow.module::' . __FUNCTION__.'/'.__LINE__);
  }
  else {
    dpm('TODO D8-port: test part of function workflow.module::' . __FUNCTION__.'/'.__LINE__);

    dpm($fields);
    if (count($fields)) {
      dpm('TODO D8-port: test part of function workflow.module::' . __FUNCTION__.'/'.__LINE__);
      // Workflow Field API: if $field_name is not known, yet, determine it.
      $field = reset($fields);
      $field_name = $field['field_name'];
    }
    else {
      dpm('TODO D8-port: test part of function workflow.module::' . __FUNCTION__.'/'.__LINE__);
      // Workflow Node API.
      $field_name = '';
    }
  }
  /*
    // If $field_name is not known, yet, determine it.
    if ($field_name === NULL) {
      dpm('TODO D8-port: test part of function workflow.module::' . __FUNCTION__.'/'.__LINE__);

      $fields = _workflow_info_fields($entity);
      dpm($fields);
      if (count($fields)) {
        // Workflow Field API: if $field_name is not known, yet, determine it.
        $field = reset($fields);
        $field_name = $field['field_name'];
      }
      else {
        // Workflow Node API.
        $field_name = '';
      }

  */
  return $sid;
}

/**
 * Gets the workflow field names, if not known already.
 *
 * For workflow_field, multiple workflows per bundle are supported.
 * For workflow_node, only one 'field' structure is returned.
 *
 * @param EntityInterface $entity
 *   Object to work with. May be empty, e.g., on menu build.
 * @param string $entity_type
 *   Entity type of object. Optional, but required if $entity provided.
 * @param string $entity_bundle
 *   Bundle of entity. Optional.
 *
 * @return array $field_info
 *   An array of field_info structures.
 */
function _workflow_info_fields($entity = NULL, $entity_type = '', $entity_bundle = '') {
  $field_info = array();
//  dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ );

  if ($entity) {
    $field_list = Drupal::entityManager()->getFieldMapByFieldType('workflow');

    // Figure out the $entity's bundle and id.
    $entity_type = $entity->getEntityTypeId();
    $entity_bundle = $entity->bundle();
    $field_list = Drupal::entityManager()->getFieldMapByFieldType('workflow');
    foreach ($field_list as $e_type => $data) {
      if (!$entity_type || ($entity_type == $e_type)) {
        foreach($data as $f_name => $data) {
          if (!$entity_bundle || isset($data['bundles'][$entity_bundle])) {
            // TODO D8-port: return FieldDefinition, not data.
            $field_info[$f_name] = $data;
            $field_info[$f_name]['entity_type'] = $e_type;
          }
        }
      }
    }
  }
  return $field_info;
}


/**
 * A wrapper around field_info_field.
 *
 * This is to hide implementation details of workflow_node.
 *
 * @param string $field_name
 *   The name of a Workflow Field. Can be empty if fetching Workflow Node.
 * @param Workflow $workflow
 *   Workflow object. Can be NULL.
 *   For a workflow_field, no $workflow is needed, since info is in field itself.
 *   For a workflow_node, $workflow provides additional data in return.
 *
 * @return array
 *   Field info structure. Pseudo data for workflow_node.
 */
function _workflow_info_field($field_name, $workflow = NULL) {
//  dpm('TODO D8-port: test function workflow.module::' . __FUNCTION__ );

  // @todo D8: remove this function when we only use workflow_field.
  $field = array();

  if ($field_name) {
    $field = field_info_field($field_name);
  }
  else {
    $field['field_name'] = '';
    $field['id'] = 0;
    $field['settings']['wid'] = 0;
    $field['settings']['widget'] = array();
    if ($workflow != NULL) {
      // $field['settings']['wid'] can be both: numeric or named.
      $field['settings']['wid'] = $workflow->wid; // @todo: to make this exportable: use machine_name??
      $field['settings']['widget'] = $workflow->options;
      $field['settings']['history']['roles'] = $workflow->tab_roles;
      $field['settings']['history']['history_tab_show'] = TRUE;
    }
    // Add default values.
    $field['settings']['widget'] += array(
      'name_as_title' => TRUE,
      'options' => 'radios',
      'schedule' => TRUE,
      'schedule_timezone' => TRUE,
      'comment_log_node' => TRUE,
      'comment_log_tab' => TRUE,
      'watchdog_log' => TRUE,
      'history_tab_show' => TRUE,
    );
  }

  return $field;
}
